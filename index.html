<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Staines</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body { margin:0; padding:0; height:100%; }
    body { background:#70c5ce; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #score {
      position:absolute; top:14px; left:14px;
      background:rgba(255,255,255,.85); color:#111; font-weight:700; font-size:22px;
      padding:6px 10px; border-radius:10px; display:none; box-shadow:0 2px 6px rgba(0,0,0,.15);
      user-select:none;
    }
    #gameCanvas { display:block; margin:0 auto; background:#70c5ce; image-rendering:pixelated; }
    #startBtn {
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:#111; color:#fff; border:none; cursor:pointer; font-weight:700; font-size:18px;
      padding:12px 22px; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.25); display:none;
    }
    @media (max-width:480px){ #gameCanvas { width:100vw; height:auto; } }
  </style>
</head>
<body>
  <div id="score">0</div>
  <canvas id="gameCanvas" width="420" height="680"></canvas>
  <button id="startBtn">Start Game</button>

  <script>
    // ===== Performance-tuned Flappy =====
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });
    ctx.imageSmoothingEnabled = false;

    const scoreEl  = document.getElementById("score");
    const startBtn = document.getElementById("startBtn");

    // Files
    const FILE_BG     = "bg.png";
    const FILE_GROUND = "ground.png";
    const FILE_PIPE_N = "tube1.png";
    const FILE_PIPE_S = "tube2.png";
    const FILE_BIRD   = "bird.png";

    const STAINES_FILE = "vote-for-staines.mp3";
    const HIT_FILE     = "sfx_hit.mp3";
    const DIE_FILE     = "sfx_die.mp3";
    const POINT_FILE   = "sfx_point.mp3";

    // Layout (integers to avoid sub-pixel work)
    const CANVAS_W = 420, CANVAS_H = 680;
    const GROUND_H = (CANVAS_H * 0.18) | 0;
    const PIPE_W   = (CANVAS_W * 0.16) | 0;
    const PIPE_H   = (CANVAS_H * 0.62) | 0;
    const GAP      = (CANVAS_H * 0.22) | 0;
    const BIRD_SZ  = (CANVAS_W * 0.11) | 0;

    // Helpers
    const loadImg = src => new Promise(r => { const i=new Image(); i.onload=()=>r(i); i.onerror=()=>r(null); i.src=src; });

    function scalify(img, w, h){
      if (!img) return null;
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const x = c.getContext('2d', { desynchronized:true });
      x.imageSmoothingEnabled = false;
      x.drawImage(img, 0, 0, w, h);
      return c;
    }

    // HTMLAudio pools for light SFX
    function makePool(src, n=3){
      const base = new Audio(src); base.preload="auto"; base.load();
      const pool = Array.from({length:n}, () => base.cloneNode(true));
      let idx = 0;
      return {
        prime(){ [base, ...pool].forEach(a => { a.play().then(()=>{a.pause();a.currentTime=0;}).catch(()=>{}); }); },
        play(){ const a = pool[idx++ % pool.length]; try{ a.currentTime=0; a.play().catch(()=>{});}catch(_){}; }
      };
    }

    const SFX = {
      hit:   makePool(HIT_FILE, 2),
      die:   makePool(DIE_FILE, 2),
      point: makePool(POINT_FILE, 2)
    };

    // WebAudio for the flap (MUCH lighter than many HTMLAudio plays)
    let audioCtx = null, stainesBuf = null;
    const FLAP_SNIP = 0.8; // seconds to play from start (trim if your file is long)

    async function loadStainesBuffer(){
      try{
        const res = await fetch(STAINES_FILE);
        const arr = await res.arrayBuffer();
        stainesBuf = await audioCtx.decodeAudioData(arr);
      }catch(e){ stainesBuf = null; }
    }
    function playStaines(){
      if (!audioCtx || !stainesBuf) return;
      try{
        const src = audioCtx.createBufferSource();
        src.buffer = stainesBuf;
        src.connect(audioCtx.destination);
        const dur = Math.min(FLAP_SNIP, stainesBuf.duration);
        src.start(0, 0, dur); // play only first X seconds to reduce load
      }catch(_){}
    }

    // Sprites (pre-scaled offscreens)
    const SPR = { bg:null, ground:null, pipeN:null, pipeS:null, bird:null };

    // State
    let frames = 0, score = 0, running = false;

    const bird = {
      x: (CANVAS_W * 0.24) | 0,
      y: (CANVAS_H * 0.35) | 0,
      w: BIRD_SZ, h: BIRD_SZ,
      gravity: 0.25, jump: 4.6, speed: 0,
      draw(){ if (SPR.bird) ctx.drawImage(SPR.bird, (this.x - this.w/2)|0, (this.y - this.h/2)|0); else { ctx.fillStyle="#ff0"; ctx.fillRect((this.x - this.w/2)|0,(this.y - this.h/2)|0,this.w,this.h);} },
      flap(){ this.speed = -this.jump; playStaines(); },
      update(){
        this.speed += this.gravity; this.y += this.speed;
        const floorY = CANVAS_H - GROUND_H;
        if ((this.y + this.h/2) >= floorY) { this.y = floorY - this.h/2; SFX.die.play(); gameOver(); }
      }
    };

    const pipes = []; // {x,y,passed}
    function spawnPipe(){
      const minTop = -(PIPE_H * 0.85) | 0;
      const maxTop = -(PIPE_H * 0.25) | 0;
      const topY   = (minTop + Math.random() * (maxTop - minTop)) | 0;
      pipes.push({ x: CANVAS_W, y: topY, passed:false });
    }
    function drawPipes(){
      for (const p of pipes) {
        ctx.drawImage(SPR.pipeN, p.x|0, p.y|0);
        ctx.drawImage(SPR.pipeS, p.x|0, (p.y + PIPE_H + GAP)|0);
      }
    }
    function updatePipes(){
      for (const p of pipes) {
        p.x -= 2;

        // AABB
        const bx1 = (bird.x - bird.w/2)|0, bx2 = (bird.x + bird.w/2)|0;
        const by1 = (bird.y - bird.h/2)|0, by2 = (bird.y + bird.h/2)|0;
        const px1 = p.x|0, px2 = (p.x + PIPE_W)|0;

        const topBottomY = (p.y + PIPE_H)|0;
        const gapEnd     = (topBottomY + GAP)|0;

        const overlapX = (bx2 > px1) && (bx1 < px2);
        const hitTop   = overlapX && (by1 < topBottomY);
        const hitBot   = overlapX && (by2 > gapEnd);

        if (hitTop || hitBot) { SFX.hit.play(); gameOver(); }

        if (!p.passed && px2 < bird.x) {
          p.passed = true;
          score++; scoreEl.textContent = score;
          SFX.point.play();
        }
      }
      if (pipes.length && pipes[0].x < -PIPE_W) pipes.shift();
      if ((frames % 50) === 0) spawnPipe(); // tuned for 30 FPS
    }

    function drawBG(){ ctx.drawImage(SPR.bg, 0, 0); }
    function drawGround(){ ctx.drawImage(SPR.ground, 0, (CANVAS_H - GROUND_H)|0); }

    function gameOver(){
      running = false;
      startBtn.style.display = "block";
      scoreEl.style.display  = "none";
      renderOnce(false);
    }

    function reset(){
      score = 0; scoreEl.textContent = score;
      pipes.length = 0; frames = 0;
      bird.y = (CANVAS_H * 0.35)|0;
      bird.speed = 0;
    }

    // --- steady 30 FPS loop ---
    const TARGET_DT = 1000 / 30;
    let last = 0;
    function loop(now){
      if (!running) return;
      if (now - last >= TARGET_DT) {
        last = now;
        frames++;
        renderOnce(true);
      }
      requestAnimationFrame(loop);
    }

    function renderOnce(run=false){
      ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
      drawBG();
      if (run) updatePipes();
      drawPipes();
      if (run) bird.update();
      bird.draw();
      drawGround();
    }

    async function startGame(){
      // init WebAudio once on user gesture
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(_) {}
        if (audioCtx) await loadStainesBuffer();
      }
      SFX.hit.prime(); SFX.die.prime(); SFX.point.prime();

      reset(); running = true;
      scoreEl.style.display = "block";
      startBtn.style.display = "none";
      last = performance.now();
      requestAnimationFrame(loop);
    }

    // inputs
    window.addEventListener("keydown", (e)=>{ if ((e.code==="Space"||e.code==="ArrowUp") && running) bird.flap(); });
    window.addEventListener("pointerdown", ()=>{ if (running) bird.flap(); });
    startBtn.addEventListener("click", startGame);

    // boot + pre-scale sprites once
    (async function boot(){
      const [bg, ground, pipeN, pipeS, birdImg] = await Promise.all([
        loadImg(FILE_BG), loadImg(FILE_GROUND), loadImg(FILE_PIPE_N), loadImg(FILE_PIPE_S), loadImg(FILE_BIRD)
      ]);

      SPR.bg     = scalify(bg, CANVAS_W, CANVAS_H - GROUND_H);
      SPR.ground = scalify(ground, CANVAS_W, GROUND_H);
      SPR.pipeN  = scalify(pipeN, PIPE_W, PIPE_H);
      SPR.pipeS  = scalify(pipeS, PIPE_W, PIPE_H);
      SPR.bird   = scalify(birdImg, BIRD_SZ, BIRD_SZ);

      canvas.width = CANVAS_W; canvas.height = CANVAS_H;
      startBtn.style.display = "block";
      renderOnce(false); // preview
    })();
  </script>

  <!-- Disable any contact-share UI from templates -->
  <script>
    (function(){
      const css = `.share,#share,.btn-share,[onclick*="share("]{display:none!important;visibility:hidden!important}`;
      const st = document.createElement('style'); st.textContent = css; document.head.appendChild(st);
      window.share = function(){};
      if (navigator.share) navigator.share = () => Promise.resolve();
      const _open = window.open;
      window.open = function(url, ...rest){
        if (typeof url === 'string' && /t\.me\/share|telegram\.me|whatsapp|facebook|twitter|mailto:/i.test(url)) return null;
        return _open ? _open(url, ...rest) : null;
      };
    })();
  </script>
</body>
</html>

