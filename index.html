<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Staines</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body { margin:0; padding:0; height:100%; }
    body { background:#70c5ce; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #score {
      position:absolute; top:14px; left:14px;
      background:rgba(255,255,255,.85); color:#111; font-weight:700; font-size:22px;
      padding:6px 10px; border-radius:10px; display:none; box-shadow:0 2px 6px rgba(0,0,0,.15);
      user-select:none;
    }
    /* ADDED: final score pill */
    #finalScore{
      position:absolute; left:50%;
      transform:translateX(-50%);
      background:rgba(0,0,0,.8); color:#fff;
      padding:12px 16px; border-radius:14px;
      font-size:20px; font-weight:800; letter-spacing:.3px;
      display:none; text-align:center; white-space:nowrap;
      box-shadow:0 10px 28px rgba(0,0,0,.25);
      user-select:none; z-index:2;
    }
    #gameCanvas { display:block; margin:0 auto; background:#70c5ce; }
    #startBtn {
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:#111; color:#fff; border:none; cursor:pointer; font-weight:700; font-size:18px;
      padding:12px 22px; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.25); display:none; z-index:1;
    }
    @media (max-width:480px){ #gameCanvas { width:100vw; height:auto; } }
  </style>
</head>
<body>
  <div id="score">0</div>
  <!-- ADDED: final score pill -->
  <div id="finalScore">Score: <span id="finalNum">0</span></div>

  <canvas id="gameCanvas" width="420" height="680"></canvas>
  <button id="startBtn">Start Game</button>

  <script>
    // ===== Fixed-layout Flappy. "VOTE FOR STAINES" plays on SCORE ONLY. =====
    const canvas   = document.getElementById("gameCanvas");
    const ctx      = canvas.getContext("2d");
    const scoreEl  = document.getElementById("score");
    const startBtn = document.getElementById("startBtn");
    // ADDED: refs for final score pill
    const finalBox = document.getElementById("finalScore");
    const finalNum = document.getElementById("finalNum");

    // ---- Filenames (match your repo) ----
    const FILE_BG      = "bg.png";
    const FILE_GROUND  = "ground.png";
    const FILE_PIPE_N  = "tube1.png";
    const FILE_PIPE_S  = "tube2.png";
    const FILE_BIRD    = "bird.png";

    // ---- Audio ----
    const STAINES_FILE = "vote-for-staines.mp3";
    const HIT_FILE     = "sfx_hit.mp3";
    const DIE_FILE     = "sfx_die.mp3";
    const POINT_FILE   = "sfx_point.mp3";

    // Low-latency: keep one base <audio> per sound and clone on play
    function makePool(src, count=4){
      const base = new Audio(src); base.preload="auto"; base.load();
      const pool = Array.from({length:count}, ()=> base.cloneNode(true));
      let i = 0;
      return {
        prime(){ // unlock on user gesture
          base.play().then(()=>{ base.pause(); base.currentTime=0; }).catch(()=>{});
          pool.forEach(a=>{ try{ a.play().then(()=>{a.pause();a.currentTime=0;}).catch(()=>{});}catch(_){} });
        },
        play(){
          const a = pool[i++ % pool.length];
          try { a.currentTime = 0; a.play().catch(()=>{}); } catch(_) {}
        }
      };
    }
    const SFX = {
      staines: makePool(STAINES_FILE, 6), // <-- plays on SCORE now
      hit:     makePool(HIT_FILE, 2),
      die:     makePool(DIE_FILE, 2),
      point:   makePool(POINT_FILE, 2)
    };

    // ---- Layout (stable) ----
    const CANVAS_W = 420, CANVAS_H = 680;
    const GROUND_H = Math.round(CANVAS_H * 0.18);
    const PIPE_W   = Math.round(CANVAS_W * 0.16);
    const PIPE_H   = Math.round(CANVAS_H * 0.62);
    const GAP      = Math.round(CANVAS_H * 0.22);
    const BIRD_SZ  = Math.round(CANVAS_W * 0.11);

    // ---- Helpers ----
    const loadImg = (src) => new Promise(res => {
      const im = new Image(); im.onload = () => res(im); im.onerror = () => res(null); im.src = src;
    });

    // ---- State ----
    let IM = { bg:null, ground:null, pipeN:null, pipeS:null, bird:null };
    let frames=0, score=0, running=false;

    const bird = {
      x: Math.floor(CANVAS_W * 0.24),
      y: Math.floor(CANVAS_H * 0.35),
      w: BIRD_SZ, h: BIRD_SZ,
      gravity: 0.25, jump: 4.6, speed: 0, rotation: 0,
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        if (IM.bird) {
          ctx.drawImage(IM.bird, -this.w/2, -this.h/2, this.w, this.h);
        } else {
          // fallback visible bird
          ctx.fillStyle="#ffcc00"; ctx.beginPath(); ctx.arc(0,0,this.w*0.5,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle="#000"; ctx.lineWidth=3; ctx.stroke();
        }
        ctx.restore();
      },
      // no sound on flap
      flap(){ this.speed = -this.jump; },
      update(){
        this.speed += this.gravity; this.y += this.speed;
        const floorY = CANVAS_H - GROUND_H;
        if (this.y + this.h/2 >= floorY) { this.y = floorY - this.h/2; SFX.die.play(); gameOver(); }
      }
    };

    const pipes = []; // {x,y,passed}
    function spawnPipe(){
      const minTop = -Math.round(PIPE_H * 0.85);
      const maxTop = -Math.round(PIPE_H * 0.25);
      const topY   = minTop + Math.random() * (maxTop - minTop);
      pipes.push({ x: CANVAS_W, y: topY, passed:false });
    }
    function drawPipes(){
      for (const p of pipes) {
        if (IM.pipeN) ctx.drawImage(IM.pipeN, p.x, p.y, PIPE_W, PIPE_H);               // TOP
        if (IM.pipeS) ctx.drawImage(IM.pipeS, p.x, p.y + PIPE_H + GAP, PIPE_W, PIPE_H); // BOTTOM
      }
    }
    function updatePipes(){
      for (const p of pipes) {
        p.x -= 2;

        // AABB collision
        const bx1 = bird.x - bird.w/2, bx2 = bird.x + bird.w/2;
        const by1 = bird.y - bird.h/2, by2 = bird.y + bird.h/2;
        const px1 = p.x, px2 = p.x + PIPE_W;

        const topBottomY = p.y + PIPE_H;
        const gapEnd     = topBottomY + GAP;

        const overlapX = (bx2 > px1) && (bx1 < px2);
        const hitTop   = overlapX && (by1 < topBottomY);
        const hitBot   = overlapX && (by2 > gapEnd);

        if (hitTop || hitBot) { SFX.hit.play(); gameOver(); }

        if (!p.passed && px2 < bird.x) {
          p.passed = true;
          score++; scoreEl.textContent = score;
          SFX.staines.play(); // voice on SCORE
          // SFX.point.play(); // (optional) keep if you also want the ding
        }
      }
      if (pipes.length && pipes[0].x < -PIPE_W) pipes.shift();
      if (frames % 100 === 0) spawnPipe();
    }

    function drawBG(){ if (IM.bg) ctx.drawImage(IM.bg, 0, 0, CANVAS_W, CANVAS_H - GROUND_H); }
    function drawGround(){ if (IM.ground) ctx.drawImage(IM.ground, 0, CANVAS_H - GROUND_H, CANVAS_W, GROUND_H); }

    // ADDED: place final score pill just above the Start button
    function showFinalScore(){
      finalNum.textContent = score;
      finalBox.style.display = "block";
      requestAnimationFrame(() => {
        const gap = 12;
        const above = Math.max(12, startBtn.offsetTop - finalBox.offsetHeight - gap);
        finalBox.style.top = `${above}px`;
      });
    }

    function gameOver(){
      running = false;
      startBtn.style.display = "block";
      scoreEl.style.display  = "none";
      showFinalScore();           // <-- ADDED
      renderOnce();               // freeze final frame
    }
    function reset(){
      score = 0; scoreEl.textContent = score;
      pipes.length = 0; frames = 0;
      bird.y = Math.floor(CANVAS_H * 0.35);
      bird.speed = 0;
      finalBox.style.display = "none"; // <-- ADDED (hide pill on restart)
    }
    function loop(){
      if (!running) return;
      frames++;
      renderOnce();
      requestAnimationFrame(loop);
    }

    function renderOnce(){
      ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
      drawBG();
      updatePipes();
      drawPipes();
      if (running) bird.update();
      bird.draw();
      drawGround();
    }

    function startGame(){
      // Prime audio so mobile plays instantly
      SFX.staines.prime(); SFX.hit.prime(); SFX.die.prime(); SFX.point.prime();

      reset(); running = true;
      scoreEl.style.display = "block";
      startBtn.style.display = "none";
      loop();
    }

    // inputs
    window.addEventListener("keydown", (e)=>{ if ((e.code==="Space"||e.code==="ArrowUp")) { if (running) bird.flap(); }});
    window.addEventListener("pointerdown", ()=>{ if (running) bird.flap(); });
    startBtn.addEventListener("click", startGame);

    // boot
    (async function boot(){
      const [bg, ground, pipeN, pipeS, birdImg] = await Promise.all([
        loadImg(FILE_BG), loadImg(FILE_GROUND), loadImg(FILE_PIPE_N), loadImg(FILE_PIPE_S), loadImg(FILE_BIRD)
      ]);
      IM = { bg, ground, pipeN, pipeS, bird: birdImg };

      canvas.width = CANVAS_W; canvas.height = CANVAS_H;
      startBtn.style.display = "block";

      // preview frame
      renderOnce();
    })();
  </script>

  <!-- ===== Disable any contact-share UI from templates ===== -->
  <script>
    (function(){
      const css = `.share,#share,.btn-share,[onclick*="share("]{display:none!important;visibility:hidden!important}`;
      const st = document.createElement('style'); st.textContent = css; document.head.appendChild(st);
      window.share = function(){};
      if (navigator.share) navigator.share = () => Promise.resolve();
      const _open = window.open;
      window.open = function(url, ...rest){
        if (typeof url === 'string' && /t\.me\/share|telegram\.me|whatsapp|facebook|twitter|mailto:/i.test(url)) return null;
        return _open ? _open(url, ...rest) : null;
      };
    })();
  </script>
</body>
</html>
