<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Staines</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body { margin:0; padding:0; height:100%; }
    body { background:#70c5ce; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #score {
      position:absolute; top:14px; left:14px;
      background:rgba(255,255,255,.85); color:#111; font-weight:700; font-size:22px;
      padding:6px 10px; border-radius:10px; display:none; box-shadow:0 2px 6px rgba(0,0,0,.15);
      user-select:none;
    }
    #gameCanvas { display:block; margin:0 auto; background:#70c5ce; }
    #startBtn {
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:#111; color:#fff; border:none; cursor:pointer; font-weight:700; font-size:18px;
      padding:12px 22px; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.25); display:none;
    }
    @media (max-width:480px){ #gameCanvas { width:100vw; height:auto; } }
  </style>
</head>
<body>
  <div id="score">0</div>
  <canvas id="gameCanvas" width="420" height="680"></canvas>
  <button id="startBtn">Start Game</button>

  <script>
    // ===== Fixed-layout Flappy (stable sizes, no reliance on image dimensions) =====
    const canvas   = document.getElementById("gameCanvas");
    const ctx      = canvas.getContext("2d");
    const scoreEl  = document.getElementById("score");
    const startBtn = document.getElementById("startBtn");

    // ---------- CANVAS LAYOUT (edit these 5 lines if you want different proportions) ----------
    const CANVAS_W   = 420, CANVAS_H = 680;                 // internal logical size
    const GROUND_H   = Math.round(CANVAS_H * 0.18);         // ground thickness (px)
    const PIPE_W     = Math.round(CANVAS_W * 0.16);         // pipe width (px)
    const PIPE_H     = Math.round(CANVAS_H * 0.62);         // pipe on-screen height (px) per segment
    const GAP        = Math.round(CANVAS_H * 0.22);         // vertical gap between pipes (px)
    const BIRD_SIZE  = Math.round(CANVAS_W * 0.11);         // bird square size (px)

    // ---------- ASSET FILENAMES (kept flexible; use any one that exists) ----------
    const IMG = {
      bg:     ["bg.png"],                     // drawn stretched
      ground: ["ground.png"],                 // drawn stretched
      pipeN:  ["tube1.png","PipeNorth.png"],  // drawn to PIPE_W x PIPE_H
      pipeS:  ["tube2.png","PipeSouth.png"],  // drawn to PIPE_W x PIPE_H
      bird:   ["smallbird.png","bird.png","player.png"] // drawn to BIRD_SIZE square
    };
    const SFX = {
      flap:   ["sfx_swooshing.mp3", "vote for staines.mp3", "vote_for_staines.mp3"],
      hit:    ["sfx_hit.mp3"], die: ["sfx_die.mp3"], point: ["sfx_point.mp3"]
    };

    // ---------- helpers ----------
    const loadImageFirst = (list) => new Promise(async (resolve) => {
      for (const src of list) {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => resolve(null);   // move on; we stretch/draw fallbacks anyway
        im.src = src;
        await new Promise(r => setTimeout(r, 0));
        if (im.complete && im.naturalWidth) return; // resolved via onload
      }
      resolve(null);
    });
    const play = (srcList) => { try { const a = new Audio(srcList[0]); a.currentTime = 0; a.play().catch(()=>{}); } catch(_){} };

    // ---------- game state ----------
    let IM = { bg:null, ground:null, pipeN:null, pipeS:null, bird:null };
    let frames = 0, score = 0, running = false;

    const bird = {
      x: Math.floor(CANVAS_W * 0.24),
      y: Math.floor(CANVAS_H * 0.35),
      w: BIRD_SIZE, h: BIRD_SIZE,
      gravity: 0.25, jump: 4.6, speed: 0, rotation: 0,
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        if (IM.bird) ctx.drawImage(IM.bird, -this.w/2, -this.h/2, this.w, this.h);
        else { ctx.fillStyle="#ffcc00"; ctx.beginPath(); ctx.arc(0,0,this.w*0.5,0,Math.PI*2); ctx.fill(); }
        ctx.restore();
      },
      flap(){ this.speed = -this.jump; play(SFX.flap); },
      update(){
        this.speed += this.gravity; this.y += this.speed;
        const floorY = CANVAS_H - GROUND_H;
        if (this.y + this.h/2 >= floorY) { this.y = floorY - this.h/2; play(SFX.die); gameOver(); }
      }
    };

    const pipes = [];  // each: {x,y,passed}
    function spawnPipe(){
      const minTop = -Math.round(PIPE_H * 0.85);
      const maxTop = -Math.round(PIPE_H * 0.25);
      const topY   = minTop + Math.random() * (maxTop - minTop);
      pipes.push({ x: CANVAS_W, y: topY, passed:false });
    }
    function drawPipes(){
      for (const p of pipes) {
        if (IM.pipeN) ctx.drawImage(IM.pipeN, p.x, p.y, PIPE_W, PIPE_H);  // top
        if (IM.pipeS) ctx.drawImage(IM.pipeS, p.x, p.y + PIPE_H + GAP, PIPE_W, PIPE_H); // bottom
      }
    }
    function updatePipes(){
      for (const p of pipes) {
        p.x -= 2;

        // AABB vs top/bottom rectangles
        const bx1 = bird.x - bird.w/2, bx2 = bird.x + bird.w/2;
        const by1 = bird.y - bird.h/2, by2 = bird.y + bird.h/2;
        const px1 = p.x, px2 = p.x + PIPE_W;

        const topBottomY = p.y + PIPE_H;
        const gapStart   = topBottomY;
        const gapEnd     = topBottomY + GAP;

        const overlapX = (bx2 > px1) && (bx1 < px2);
        const hitTop   = overlapX && (by1 < topBottomY);
        const hitBot   = overlapX && (by2 > gapEnd);

        if (hitTop || hitBot) { play(SFX.hit); gameOver(); }

        if (!p.passed && px2 < bird.x) { p.passed = true; score++; scoreEl.textContent = score; play(SFX.point); }
      }
      if (pipes.length && pipes[0].x < -PIPE_W) pipes.shift();
      if (frames % 100 === 0) spawnPipe();
    }

    function drawBG(){ if (IM.bg) ctx.drawImage(IM.bg, 0, 0, CANVAS_W, CANVAS_H - GROUND_H); }
    function drawGround(){ if (IM.ground) ctx.drawImage(IM.ground, 0, CANVAS_H - GROUND_H, CANVAS_W, GROUND_H); }

    function gameOver(){
      running = false;
      startBtn.style.display = "block";
      scoreEl.style.display  = "none";
    }
    function reset(){
      score = 0; scoreEl.textContent = score;
      pipes.length = 0; frames = 0;
      bird.y = Math.floor(CANVAS_H * 0.35);
      bird.speed = 0;
    }
    function loop(){
      if (!running) return;
      frames++;
      ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
      drawBG();
      updatePipes();
      drawPipes();
      bird.update(); bird.draw();
      drawGround();
      requestAnimationFrame(loop);
    }
    function startGame(){
      reset(); running = true;
      scoreEl.style.display = "block";
      startBtn.style.display = "none";
      loop();
    }

    // input
    window.addEventListener("keydown", (e)=>{ if ((e.code==="Space"||e.code==="ArrowUp") && running) bird.flap(); });
    window.addEventListener("pointerdown", ()=>{ if (running) bird.flap(); });
    startBtn.addEventListener("click", startGame);

    // boot: load images (we don't use their sizes), then reveal start
    (async function boot(){
      const [bg, ground, pipeN, pipeS, birdImg] = await Promise.all([
        loadImageFirst(IMG.bg), loadImageFirst(IMG.ground),
        loadImageFirst(IMG.pipeN), loadImageFirst(IMG.pipeS),
        loadImageFirst(IMG.bird)
      ]);
      IM = { bg, ground, pipeN, pipeS, bird: birdImg };

      // force canvas logical size (in case HTML editors changed it)
      canvas.width = CANVAS_W; canvas.height = CANVAS_H;

      startBtn.style.display = "block";
    })();
  </script>

  <!-- ===== Kill "share to contacts" (no popups) ===== -->
  <script>
    (function(){
      const css = `.share,#share,.btn-share,[onclick*="share("]{display:none!important;visibility:hidden!important}`;
      const st = document.createElement('style'); st.textContent = css; document.head.appendChild(st);
      window.share = function(){};
      if (navigator.share) navigator.share = () => Promise.resolve();
      const _open = window.open;
      window.open = function(url, ...rest){
        if (typeof url === 'string' && /t\.me\/share|telegram\.me|whatsapp|facebook|twitter|mailto:/i.test(url)) return null;
        return _open ? _open(url, ...rest) : null;
      };
    })();
  </script>
</body>
</html>
